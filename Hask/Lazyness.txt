ByteString, Map, etc...... 诸多的haskell数据结构库都有Strict/Lazy双版本，为什么呢? 暴力犯罪层出不穷......啊不是，是因为效率!

看起来所有时候都是Lazy能比较减少运算和遍历，但是实际上一个嵌套过深的Thunk很容易引发haskell圈中称为“Space Leak”的致命情况，会有多大的性能差别呢？我用实例来说明一下。

前几日我尝试用haskell实现Dijkstra最小路径算法，我用Map (Vertex,Vertex) (Maybe Int)实现邻接矩阵，当然是Lazy的。为了改变状态，我用了一个尾递归函数模仿循环。然后编译完惊喜来了，一个6顶点的图把我的手机内存吃光了，直接重启。我以为是写出死递归了，换了个3顶点的图，没问题，内存只用了2MB。然后我抱着试试看的想法用了DeepSeq强制急切求值，然后6顶点的图也很快就解出来了，也只用了2MB........

啊当然后来发现算法实现的不对，别介意。

